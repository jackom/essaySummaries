####命令行模式和Python交互模式

*   1、看到类似c:\>是在Windows提供的命令行模式，在命令行模式下，可以执行python进入Python交互式环境，也可以执行python hello.py运行一个.py文件。

*   2、看到>>>是在Python交互式环境下，在Python交互式环境下，只能输入Python代码并立刻执行。

#####此外，在命令行模式运行.py文件和在Python交互式环境下直接运行Python代码有所不同。Python交互式环境会把每一行Python代码的结果自动打印出来，但是，直接运行Python代码却不会。

例如，在Python交互式环境下，输入：

<pre><code>>>> 100 + 200 + 300
600
</code></pre>
直接可以看到结果600。<br/>
但是，写一个calc.py的文件，内容如下：

<pre><code>100 + 200 + 300
</code></pre>
然后在命令行模式下执行：

<pre><code>C:\work>python calc.py
</code></pre>
发现什么输出都没有。

这是正常的。想要输出结果，必须自己用print()打印出来。把calc.py改造一下：

<pre><code>print(100 + 200 + 300)
</code></pre>
再执行，就可以看到结果：

<pre><code>C:\work>python calc.py
600
</code></pre>

#####直接运行py文件
有同学问，能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释：
<pre><code>C:\work>#!/usr/bin/env python3
print('hello, world')
</code></pre>
然后，通过命令给hello.py以执行权限：
<pre><code>$ chmod a+x hello.py
</code></pre>
就可以直接运行hello.py了

#####Python的交互模式和直接运行.py文件有什么区别呢？
1、直接输入python进入交互模式，相当于启动了Python解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。

2、直接运行.py文件相当于启动了Python解释器，然后一次性把.py文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。

</br>
</br>

#####输入和输出
print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：

<pre><code>print('The quick brown fox', 'jumps over', 'the lazy dog')
The quick brown fox jumps over the lazy dog
</code></pre>

print()会依次打印每个字符串，遇到逗号“,”会输出一个空格.

</br>
</br>

#####Python是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。Python也不例外。

#####Python的语法比较简单，采用缩进方式，写出来的代码就像下面的样子：

<pre><code># print absolute value of an integer:
a = 100
if a >= 0:
    print(a)
else:
    print(-a)
</code></pre>

以#开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块。

缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的管理，应该始终坚持使用4个空格的缩进。

缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若干函数，从而得到缩进较少的代码。

缩进的坏处就是“复制－粘贴”功能失效了，这是最坑爹的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像格式化Java代码那样格式化Python代码。

最后，请务必注意，Python程序是大小写敏感的，如果写错了大小写，程序会报错。

#####小结

Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。
在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。

</br>
</br>

#####在Python中，能够直接处理的数据类型有以下几种(整数、浮点数、字符串、空值、变量、常量)：

#####整数：
Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。

计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。

这里解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：

<pre><code>>>> 10 / 3
3.3333333333333335
</code></pre>

/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：

<pre><code>>>> 9 / 3
3.0</code></pre>

还有一种除法是//，称为地板除，两个整数的除法仍然是整数：

<pre><code>>>> 10 // 3
3</code></pre>

你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。

因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：

<pre><code>>>> 10 % 3
1</code></pre>

无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。

#####浮点数：

浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。

整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。

#####字符串
字符串是以单引号'或双引号"括起来的任意文本，比如'abc'，"xyz"等等。请注意，''或""本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。如果'本身也是一个字符，那就可以用""括起来，比如"I'm OK"包含的字符是I，'，m，空格，O，K这6个字符。

如果字符串内部既包含'又包含"怎么办？可以用转义字符\来标识，比如：

<pre><code>'I\'m \"OK\"!'</code></pre>
表示的字符串内容是：

<pre><code>I'm "OK"!</code></pre>

转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：

<pre><code>>>> print('I\'m ok.')
I'm ok.
>>> print('I\'m learning\nPython.')
I'm learning
Python.
>>> print('\\\n\\')
\
\</code></pre>

如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r''表示''内部的字符串默认不转义，可以自己试试：

<pre><code>>>> print('\\\t\\')
\       \
>>> print(r'\\\t\\')
\\\t\\</code></pre>

如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容，可以自己试试：

<pre><code>>>> print('''line1
... line2
... line3''')
line1
line2
line3</code></pre>

上面是在交互式命令行内输入，注意在输入多行内容时，提示符由>>>变为...，提示你可以接着上一行输入。如果写成程序，就是：

<pre><code>print('''line1
line2
line3''')</code></pre>

多行字符串'''...'''还可以在前面加上r使用，请自行测试。

#####布尔值
布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写）

布尔值可以用and、or和not运算。

1、and运算是与运算，只有所有都为True，and运算结果才是True;

2、or运算是或运算，只要其中有一个为True，or运算结果就是True；

3、not运算是非运算，它是一个单目运算符，把True变成False，False变成True

#####空值

空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。

此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型

#####变量
变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头

在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：

<pre><code>a = 123 # a是整数
print(a)
a = 'ABC' # a变为字符串
print(a)</code></pre>

这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：

<pre><code>int a = 123; // a是整数类型变量
a = "ABC"; // 错误：不能把字符串赋给整型变量</code></pre>

和静态语言相比，动态语言更灵活，就是这个原因。

######当我们写：

<pre><code>a = 'ABC'</code></pre>

时，Python解释器干了两件事情：

- 在内存中创建了一个'ABC'的字符串；

- 在内存中创建了一个名为a的变量，并把它指向'ABC'。

也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：

<pre><code>a = 'ABC'
b = a
a = 'XYZ'
print(b)</code></pre>

最后一行打印出变量b的内容到底是'ABC'呢还是'XYZ'？如果从数学意义上理解，就会错误地得出b和a相同，也应该是'XYZ'，但实际上b的值是'ABC'

#####常量

所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量

#####注意：
Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。

Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。

#####字符编码
Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。

现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。

字母A用ASCII编码是十进制的65，二进制的01000001；

字符0用ASCII编码是十进制的48，二进制的00110000，注意字符'0'和整数0是不同的；

汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。

你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。

新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。

所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：

<pre><code>字符	ASCII	       Unicode	        UTF-8
A	01000001	00000000 01000001	  01000001
中	x	       01001110 00101101	11100100 10111000 10101101</code></pre>

从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。

搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：

在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。

- 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件

- 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器

对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：

<pre><code>>>> ord('A')
65
>>> ord('中')
20013
>>> chr(66)
'B'
>>> chr(25991)
'文'</code></pre>

如果知道字符的整数编码，还可以用十六进制这么写str：

<pre><code>>>> '\u4e2d\u6587'
'中文'</code></pre>

两种写法完全是等价的。

由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。

Python对bytes类型的数据用带b前缀的单引号或双引号表示：

<pre><code>x = b'ABC'</code></pre>

要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。

以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：

<pre><code>>>> 'ABC'.encode('ascii')
b'ABC'
>>> '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
>>> '中文'.encode('ascii')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)</code></pre>

纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。

在bytes中，无法显示为ASCII字符的字节，用\x##显示。

反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：

<pre><code>>>> b'ABC'.decode('ascii')
'ABC'
>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'</code></pre>

在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。

由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：

<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-</code></pre>

第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；

第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。

- 申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码

- 如果.py文件本身使用UTF-8编码，并且也申明了# -*- coding: utf-8 -*-，打开命令提示符测试就可以正常显示中文

#####格式化
格式化整数和浮点数还可以指定是否补0和整数与小数的位数：

<pre><code>>>> '%2d-%02d' % (3, 1)
' 3-01'
>>> '%.2f' % 3.1415926
'3.14'
>>> '%.1f' % 3.1415926
'3.1'
>>> '%.f' % 3.1415926
'3'</code></pre>

如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：

<pre><code>>>> 'Age: %s. Gender: %s' % (25, True)
'Age: 25. Gender: True'</code></pre>

有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：

<pre><code>>>> 'growth rate: %d %%' % 7
'growth rate: 7 %'</code></pre>

#####小结
Python 3的字符串使用Unicode，直接支持多语言。

str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312：

<pre><code>>>> '中文'.encode('gb2312')
b'\xd6\xd0\xce\xc4'</code></pre>

但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。

格式化字符串的时候，可以用Python的交互式命令行测试，方便快捷。

#####使用list和tuple
list

Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。

比如，列出班里所有同学的名字，就可以用一个list表示：

<pre><code>>>> classmates = ['Michael', 'Bob', 'Tracy']
>>> classmates
['Michael', 'Bob', 'Tracy']</code></pre>


