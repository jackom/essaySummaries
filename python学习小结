####命令行模式和Python交互模式

*   1、看到类似c:\>是在Windows提供的命令行模式，在命令行模式下，可以执行python进入Python交互式环境，也可以执行python hello.py运行一个.py文件。

*   2、看到>>>是在Python交互式环境下，在Python交互式环境下，只能输入Python代码并立刻执行。

#####此外，在命令行模式运行.py文件和在Python交互式环境下直接运行Python代码有所不同。Python交互式环境会把每一行Python代码的结果自动打印出来，但是，直接运行Python代码却不会。

例如，在Python交互式环境下，输入：

<pre><code>>>> 100 + 200 + 300
600
</code></pre>
直接可以看到结果600。<br/>
但是，写一个calc.py的文件，内容如下：

<pre><code>100 + 200 + 300
</code></pre>
然后在命令行模式下执行：

<pre><code>C:\work>python calc.py
</code></pre>
发现什么输出都没有。

这是正常的。想要输出结果，必须自己用print()打印出来。把calc.py改造一下：

<pre><code>print(100 + 200 + 300)
</code></pre>
再执行，就可以看到结果：

<pre><code>C:\work>python calc.py
600
</code></pre>

#####直接运行py文件
有同学问，能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释：
<pre><code>C:\work>#!/usr/bin/env python3
print('hello, world')
</code></pre>
然后，通过命令给hello.py以执行权限：
<pre><code>$ chmod a+x hello.py
</code></pre>
就可以直接运行hello.py了

#####Python的交互模式和直接运行.py文件有什么区别呢？
1、直接输入python进入交互模式，相当于启动了Python解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。

2、直接运行.py文件相当于启动了Python解释器，然后一次性把.py文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。

</br>
</br>

#####输入和输出
print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：

<pre><code>print('The quick brown fox', 'jumps over', 'the lazy dog')
The quick brown fox jumps over the lazy dog
</code></pre>

print()会依次打印每个字符串，遇到逗号“,”会输出一个空格.

</br>
</br>

#####Python是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。Python也不例外。

#####Python的语法比较简单，采用缩进方式，写出来的代码就像下面的样子：

<pre><code># print absolute value of an integer:
a = 100
if a >= 0:
    print(a)
else:
    print(-a)
</code></pre>

以#开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块。

缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的管理，应该始终坚持使用4个空格的缩进。

缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若干函数，从而得到缩进较少的代码。

缩进的坏处就是“复制－粘贴”功能失效了，这是最坑爹的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像格式化Java代码那样格式化Python代码。

最后，请务必注意，Python程序是大小写敏感的，如果写错了大小写，程序会报错。

#####小结

Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。
在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。

</br>
</br>

#####在Python中，能够直接处理的数据类型有以下几种(整数、浮点数、字符串、空值、变量、常量)：

#####整数：
Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。

计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。

这里解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：

<pre><code>>>> 10 / 3
3.3333333333333335
</code></pre>

/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：

<pre><code>>>> 9 / 3
3.0</code></pre>

还有一种除法是//，称为地板除，两个整数的除法仍然是整数：

<pre><code>>>> 10 // 3
3</code></pre>

你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。

因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：

<pre><code>>>> 10 % 3
1</code></pre>

无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。

#####浮点数：

浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。

整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。

#####字符串
字符串是以单引号'或双引号"括起来的任意文本，比如'abc'，"xyz"等等。请注意，''或""本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。如果'本身也是一个字符，那就可以用""括起来，比如"I'm OK"包含的字符是I，'，m，空格，O，K这6个字符。

如果字符串内部既包含'又包含"怎么办？可以用转义字符\来标识，比如：

<pre><code>'I\'m \"OK\"!'</code></pre>
表示的字符串内容是：

<pre><code>I'm "OK"!</code></pre>

转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：

<pre><code>>>> print('I\'m ok.')
I'm ok.
>>> print('I\'m learning\nPython.')
I'm learning
Python.
>>> print('\\\n\\')
\
\</code></pre>

如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r''表示''内部的字符串默认不转义，可以自己试试：

<pre><code>>>> print('\\\t\\')
\       \
>>> print(r'\\\t\\')
\\\t\\</code></pre>

如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容，可以自己试试：

<pre><code>>>> print('''line1
... line2
... line3''')
line1
line2
line3</code></pre>

上面是在交互式命令行内输入，注意在输入多行内容时，提示符由>>>变为...，提示你可以接着上一行输入。如果写成程序，就是：

<pre><code>print('''line1
line2
line3''')</code></pre>

多行字符串'''...'''还可以在前面加上r使用，请自行测试。

#####布尔值
布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写）

布尔值可以用and、or和not运算。

1、and运算是与运算，只有所有都为True，and运算结果才是True;

2、or运算是或运算，只要其中有一个为True，or运算结果就是True；

3、not运算是非运算，它是一个单目运算符，把True变成False，False变成True

#####空值

空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。

此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型

#####变量
变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头

在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：

<pre><code>a = 123 # a是整数
print(a)
a = 'ABC' # a变为字符串
print(a)</code></pre>

这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：

<pre><code>int a = 123; // a是整数类型变量
a = "ABC"; // 错误：不能把字符串赋给整型变量</code></pre>

和静态语言相比，动态语言更灵活，就是这个原因。

######当我们写：

<pre><code>a = 'ABC'</code></pre>

时，Python解释器干了两件事情：

- 在内存中创建了一个'ABC'的字符串；

- 在内存中创建了一个名为a的变量，并把它指向'ABC'。

也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：

<pre><code>a = 'ABC'
b = a
a = 'XYZ'
print(b)</code></pre>

最后一行打印出变量b的内容到底是'ABC'呢还是'XYZ'？如果从数学意义上理解，就会错误地得出b和a相同，也应该是'XYZ'，但实际上b的值是'ABC'

#####常量

所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量

#####注意：
Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。

Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。

#####字符编码
Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。

现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。

字母A用ASCII编码是十进制的65，二进制的01000001；

字符0用ASCII编码是十进制的48，二进制的00110000，注意字符'0'和整数0是不同的；

汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。

你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。

新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。

所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：

<pre><code>字符	ASCII	       Unicode	        UTF-8
A	01000001	00000000 01000001	  01000001
中	x	       01001110 00101101	11100100 10111000 10101101</code></pre>

从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。

搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：

在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。

- 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件

- 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器

对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：

<pre><code>>>> ord('A')
65
>>> ord('中')
20013
>>> chr(66)
'B'
>>> chr(25991)
'文'</code></pre>

如果知道字符的整数编码，还可以用十六进制这么写str：

<pre><code>>>> '\u4e2d\u6587'
'中文'</code></pre>

两种写法完全是等价的。

由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。

Python对bytes类型的数据用带b前缀的单引号或双引号表示：

<pre><code>x = b'ABC'</code></pre>

要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。

以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：

<pre><code>>>> 'ABC'.encode('ascii')
b'ABC'
>>> '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
>>> '中文'.encode('ascii')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)</code></pre>

纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。

在bytes中，无法显示为ASCII字符的字节，用\x##显示。

反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：

<pre><code>>>> b'ABC'.decode('ascii')
'ABC'
>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'</code></pre>

在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。

由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：

<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-</code></pre>

第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；

第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。

- 申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码

- 如果.py文件本身使用UTF-8编码，并且也申明了# -*- coding: utf-8 -*-，打开命令提示符测试就可以正常显示中文

#####格式化
格式化整数和浮点数还可以指定是否补0和整数与小数的位数：

<pre><code>>>> '%2d-%02d' % (3, 1)
' 3-01'
>>> '%.2f' % 3.1415926
'3.14'
>>> '%.1f' % 3.1415926
'3.1'
>>> '%.f' % 3.1415926
'3'</code></pre>

如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：

<pre><code>>>> 'Age: %s. Gender: %s' % (25, True)
'Age: 25. Gender: True'</code></pre>

有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：

<pre><code>>>> 'growth rate: %d %%' % 7
'growth rate: 7 %'</code></pre>

#####小结
Python 3的字符串使用Unicode，直接支持多语言。

str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312：

<pre><code>>>> '中文'.encode('gb2312')
b'\xd6\xd0\xce\xc4'</code></pre>

但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。

格式化字符串的时候，可以用Python的交互式命令行测试，方便快捷。

#####使用list和tuple
list

Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。

比如，列出班里所有同学的名字，就可以用一个list表示：

<pre><code>>>> classmates = ['Michael', 'Bob', 'Tracy']
>>> classmates
['Michael', 'Bob', 'Tracy']</code></pre>

常用的方法有：
append(element)往list中追加元素到末尾；
insert(i, element)把元素插入到指定的位置；
pop()删除list末尾的元素；
pop(i)，其中i是索引位置，删除指定位置的元素；

tuple(元组):
tuple一旦初始化就不能修改(这里是指它的指向不能改变)，它也没有append(),insert()这样的方法

<pre><code>>>> t = (1, 2)
>>> t
(1, 2)</code></pre>

定义一个空的tuple，如下：

<pre><code>>>> t = ()
>>> t
()
</code></pre>

定义只有一个元素的tuple：

<pre><code>>>> t = (1,)
>>> t
(1,)</code></pre>

如果写成 t = (1)，那么python是按照小括号进行计算，计算结果自然是1(括号()既可以表示tuple，又可以表示数学公式中的小括号)

<pre><code>
>>> t = ('a', 'b', ['A', 'B'])
>>> t[2][0] = 'X'
>>> t[2][1] = 'Y'
>>> t
('a', 'b', ['X', 'Y'])
</code></pre>

<b>tuple所谓的"不变"是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改为指向'b'，指向一个list，就不能改为指向其他对象，但指向的这个list本身是可变的!</b>


input()返回的数据类型是str,str不能直接和整数比较,必须先把str转换为整数

<pre><code>>>> list(range(5))
[0, 1, 2, 3, 4]
</code></pre>

range()函数，可以用来生成一个整数序列,range(5)生成的序列是从0开始小于5的整数

Ctrl + C 退出程序

#####dict:

dict全称dictionary，使用键-值(key-value)存储，具有较快的查找速度

<pre><code>>>> d = {"Michael":95, "Bob":75, "Tracy":85}
>>> d["Michael"]
95
</code></pre>

dict的实现原理和查字典是一样的，给定一个名字，比如"Michael"，dict在内部就可以直接计算Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。

把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：

<pre><code>>>> d["Adam"] = 67
>>> d["Adam"] 
67</code></pre>

要避免key不存在的错误，有两种方法，一是通过in判断key是否存在：

<pre><code>>>> "Jack" in d
False</code></pre>

二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：

<pre><code>>>> d.get("Jack")
>>> print(d.get("Jack"))
None
>>> d.get("Jack", -1)
-1</code></pre>

注意：返回None的时候Python的交互环境不显示结果

要删除一个key，用pop(key)方法，对应的value也会从dict中删除

注意：dict内部存放的顺序和key放入的顺序是没有关系的

####dict和list的对比：
和list比较，dict有以下几个特点：
- 查找和插入的时间随着元素的增加而增加；
-需要占用大量的内存，内存浪费多。

而list相反：
- 查找和插入的时间随着元素的增加而增加；
- 占用空间小，浪费内存很少。

所以，dict使用空间来换取时间的一种方法。

dict的key必须是不可变对象！！！

#####set

set和dict类似，也是一组key的集合，而不存储value。由于key不能重复，所以，在set中，没有重复的key

重复元素在set中自动被过滤:

<pre><code>>>> s = set([1, 2, 2, 2, 3, 4])
>>> s
{1, 2, 3, 4}</code></pre>

通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果

通过remove(key)方法可以删除元素

set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：

<pre><code>>>> s1 = set([1, 2, 3])
>>> s2 = set([2, 3, 4])
>>> s1 & s2
{2, 3}
>>> s1 | s2
{1, 2, 3, 4}</code></pre>

set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部”不会有重复元素”。

对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。


#####Python内置了很多有用的函数，我们可以直接调用。

要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接从Python的官方网站查看文档：

http://docs.python.org/3/library/functions.html#abs

也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。<b>其中，在交互式命令行里面输入 help(abs)后，可通过输入 q 退出当前界面</b>

函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个”别名”：


<pre><code>>>> a = abs #变量a指向abs函数
>>> a(-1) #所以也可以通过a调用abs函数
1
</code></pre>


函数： 定义的函数如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return


对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：
<pre><code>def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x >= 0:
        return x
    else:
        return -x
</code></pre>


函数返回多个值：函数可以同时返回多个值，但其实就是一个tuple。在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。

Python的函数定义非常简单，但灵活度却非常大。<b>除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，</b>使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。
</br>
#####默认参数:
默认参数可以简化函数的调用。设置默认参数时，有几点要注意：

- 是必选参数在前，默认参数在后，否则Python的解释器会报错；
- 是如何设置默认参数。

当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

使用默认参数有什么好处？最大的好处是能降低调用函数的难度。
<pre><code>def enroll(name, gender, age=6, city='Beijing'):
    print 'name:', name
    print 'gender:', gender
    print 'age:', age
    print 'city:', city
</code></pre>

<pre><code>enroll('Bob', 'M', 7)
enroll('Adam', 'M', city='Tianjin')
</code></pre>

可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。

有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll('Bob', 'M', 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。

也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin')，意思是，city参数用传进去的值，其他默认参数继续使用默认值。

定义默认参数要牢记一点：默认参数必须指向不变对象！

<b>备注：</b>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。

[Default Parameter Values in Python](http://effbot.org/zone/default-values.htm)

<pre><code>>>> def test_add_end(L=[]):
...     print 'L :', L
...     L.append('END')
...     return L
...
>>> test_add_end()
L : []
['END']
>>> test_add_end()
L : ['END']
['END', 'END']
>>> test_add_end([1, 2])
L : [1, 2]
[1, 2, 'END']
>>> test_add_end([4, 5])
L : [4, 5]
[4, 5, 'END']
>>> id(test_add_end())
L : ['END', 'END']
4390624720
>>> id(test_add_end())
L : ['END', 'END', 'END']
4390624720
>>> id(test_add_end())
L : ['END', 'END', 'END', 'END']
4390624720</code></pre>

<pre><code>def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
</code></pre>

<b>原因解释如下：</b>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。

#####可变参数
在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。

<pre><code>def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum</code></pre>

定义可变参数和定义list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：

<pre><code>>>> calc(1, 2)
5
>>> calc()
0</code></pre>

Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：

<pre><code>>>> nums = [1, 2, 3]
>>> calc(*nums)
14</code></pre>

#####关键字参数

可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。

<pre><code>def person(name, age, **kw):
    print 'name:', name, 'age:', age, 'other:', kw</code></pre>

<pre><code>>>> person('Michael', 30)
name: Michael age: 30 other: {}
>>> person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}</code></pre>

关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。

和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：

<pre><code>>>> kw = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, city=kw['city'], job=kw['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
>>> kw = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **kw)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}</code></pre>

######参数组合

在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。

<pre><code>def func(a, b, c=0, *args, **kw):
    print 'a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw</code></pre>

在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。

<pre><code>>>> func(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
>>> func(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
>>> func(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
>>> func(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}</code></pre>

最神奇的是通过一个tuple和dict，你也可以调用该函数：

<pre><code>>>> args = (1, 2, 3, 4)
>>> kw = {'x': 99}
>>> func(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'x': 99}</code></pre>

所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。

#####小结

Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。

<b>默认参数一定要用不可变对象，如果是可变对象，运行会有逻辑错误！</b>

要注意定义可变参数和关键字参数的语法：

*args是可变参数，args接收的是一个tuple；

**kw是关键字参数，kw接收的是一个dict。

以及调用函数时如何传入可变参数和关键字参数的语法：

可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过\*args传入：func(*(1, 2, 3))；

关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过\*\*kw传入：func(**{'a': 1, 'b': 2})。

使用\*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。

#####递归函数
在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。

举个例子，我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示:

<pre><code>def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)</code></pre>            

使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

<pre><code>>>> fact(1000)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 4, in fact
  ...
  File "&lt;stdin&gt;", line 4, in fact
RuntimeError: maximum recursion depth exceeded</code></pre> 

解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

<b>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</b>

<pre><code>def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)</code></pre> 

可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。

尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。

遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。

#####小结

使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。

针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。

Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。


切片操作十分有用。我们先创建一个0-99的数列：

<pre><code>>>> L = range(100)
>>> L
[0, 1, 2, 3, ..., 99]</code></pre> 

可以通过切片轻松取出某一段数列。比如前10个数：

<pre><code>>>> L[:10]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre> 

后10个数：
<pre><code>>>> L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</code></pre> 

前11-20个数：
<pre><code>>>> L[10:20]
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</code></pre> 

前10个数，每两个取一个：
<pre><code>>>> L[:10:2]
[0, 2, 4, 6, 8]</code></pre> 

所有数，每5个取一个：
<pre><code>>>> L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]</code></pre> 

甚至什么都不写，只写[:]就可以原样复制一个list：
<pre><code>>>> L[:]
[0, 1, 2, 3, ..., 99]</code></pre> 

tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：
<pre><code>>>> (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)</code></pre> 

字符串'xxx'或Unicode字符串u'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：

<pre><code>>>> 'ABCDEFG'[:3]
'ABC'
>>> 'ABCDEFG'[::2]
'ACEG'</code></pre> 

在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。

<b>备注：</b>因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。

默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.itervalues()，如果要同时迭代key和value，可以用for k, v in d.iteritems()。

如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：

<pre><code>>>> from collections import Iterable
>>> isinstance('abc', Iterable) # str是否可迭代
True
>>> isinstance([1,2,3], Iterable) # list是否可迭代
True
>>> isinstance(123, Iterable) # 整数是否可迭代
False</code></pre> 

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

<pre><code>>>> for i, value in enumerate(['A', 'B', 'C']):
...     print i, value
...
0 A
1 B
2 C</code></pre> 

<pre><code>>>> for x, y in [(1, 1), (2, 4), (3, 9)]:
...     print x, y
...
1 1
2 4
3 9</code></pre> 

#####小结

任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。

<b>对于切片（Slice）操作符，有如下规则(以list为例，L[start:stop:step])：</b>

- 符号相同时：start < stop 时才会返回数据
- 符号异同时：start > stop 时才会返回数据
- 其他情况返回 []

#####列表生成式
列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。

要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：

<pre><code>>>> L = []
>>> for x in range(1, 11):
...    L.append(x * x)
...
>>> L
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></pre> 

但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：

<pre><code>>>> [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></pre> 

筛选出仅偶数的平方：

<pre><code>>>> [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]</code></pre> 

还可以使用两层循环，可以生成全排列：

<pre><code>>>> [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']</code></pre> 

三层和三层以上的循环就很少用到了。

运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：

<pre><code>>>> import os # 导入os模块，模块的概念后面讲到
>>> [d for d in os.listdir('.')] # os.listdir可以列出文件和目录
['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode']</code></pre>

for循环其实可以同时使用两个甚至多个变量，比如dict的iteritems()可以同时迭代key和value：

<pre><code>>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> for k, v in d.iteritems():
...     print k, '=', v
... 
y = B
x = A
z = C</code></pre> 

因此，列表生成式也可以使用两个变量来生成list：

<pre><code>>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> [k + '=' + v for k, v in d.iteritems()]
['y=B', 'x=A', 'z=C']</code></pre> 

最后把一个list中所有的字符串变成小写：

<pre><code>>>> L = ['Hello', 'World', 'IBM', 'Apple']
>>> [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']</code></pre> 

<b>**列表推导式：**</b>

<pre><code>def transpose(M):
    return [list(col) for col in zip(*M)]
</code></pre> 
    
[参考资料一](https://docs.python.org/dev/tutorial/controlflow.html#unpacking-argument-lists)
[参考资料二](https://python3-cookbook.readthedocs.io/zh_CN/latest/c04/p11_iterate_over_multiple_sequences_simultaneously.html)

<pre><code>def matxMultiply(A,B):
    _, c = shape(A)
    r, _ = shape(B)
    if c != r :
        raise ValueError
    Bt = transpose(B)
    result = [[sum((a*b) for a,b in zip(row,col)) for col in Bt] for row in A]
    return result
</code></pre> 

<pre><code>def augmentMatrix(A, b):
    return [ra + rb for ra,rb in zip(A,b)]
</code></pre> 

<pre><code>In [1]: a = [1,2,3]
In [2]: b = [4,5]
In [3]: a + b
Out[3]: [1, 2, 3, 4, 5]
</code></pre> 

#####生成器

通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。

要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：

<pre><code>>>> L = [x * x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x * x for x in range(10))
>>> g
&lt;generator object &lt;genexpr&gt; at 0x104feab40&gt;
</code></pre> 

我们讲过，generator保存的是算法，每次调用next()，就计算出下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。

当然，上面这种不断调用next()方法实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：

<pre><code>>>> g = (x * x for x in range(10))
>>> for n in g:
...     print n
...
0
1
4
9
16
25
36
49
64
81</code></pre> 

所以，我们创建了一个generator后，基本上永远不会调用next()方法，而是通过for循环来迭代它。

generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。

比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：

1, 1, 2, 3, 5, 8, 13, 21, 34, ...

斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：

<pre><code>def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        print b
        a, b = b, a + b
        n = n + 1</code></pre> 

上面的函数可以输出斐波那契数列的前N个数：

<pre><code>>>> fib(6)
1
1
2
3
5
8</code></pre> 

仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。

也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print b改为yield b就可以了：

<pre><code>def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1</code></pre> 

这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：

<pre><code>>>> fib(6)
&lt;generator object fib at 0x104feaaa0&gt;</code></pre> 

这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。

举个简单的例子，定义一个generator，依次返回数字1，3，5：

<pre><code>>>> def odd():
...     print 'step 1'
...     yield 1
...     print 'step 2'
...     yield 3
...     print 'step 3'
...     yield 5
...
>>> o = odd()
>>> o.next()
step 1
1
>>> o.next()
step 2
3
>>> o.next()
step 3
5
>>> o.next()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration</code></pre> 

可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next()就报错。

回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。

同样的，把函数改成generator后，我们基本上从来不会用next()来调用它，而是直接使用for循环来迭代：

<pre><code>>>> for n in fib(6):
...     print n
...
1
1
2
3
5
8</code></pre> 

#####小结

generator是非常强大的工具，在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。

要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。

对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。

<b>函数式编程</b>就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。

函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！

Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。

#####高阶函数
高阶函数英文叫Higher-order function(既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。)

变量可以指向函数

<pre><code>>>> f = abs
>>> f
&lt;built-in function abs&gt;</code></pre> 

结论：函数本身也可以赋值给变量，即：变量可以指向函数。

<pre><code>>>> f = abs
>>> f(-10)
10</code></pre> 

成功！说明变量f现在已经指向了abs函数本身。

函数名也是变量(函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！)

如果把abs指向其他对象，会有什么情况发生？

<pre><code>>>> abs = 10
>>> abs(-10)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'int' object is not callable</code></pre> 

把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数了！

当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。

注：由于abs函数实际上是定义在__builtin__模块中的，所以要让修改abs变量的指向在其它模块也生效，要用__builtin__.abs = 10。

编写高阶函数，就是让函数的参数能够接收别的函数。

<b>把函数作为参数传入，这样的函数称为高阶函数</b>，函数式编程就是指这种高度抽象的编程范式。

<b>map/reduce</b>

map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。

举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：

<pre><code>>>> def f(x):
...     return x * x
...
>>> map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
[1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre> 

把这个list所有数字转为字符串：

<pre><code>>>> map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])
['1', '2', '3', '4', '5', '6', '7', '8', '9']</code></pre> 

reduce把一个函数作用在一个序列[x1, x2, x3...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：

<pre><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></pre> 

比方说对一个序列求和，就可以用reduce实现：

<pre><code>>>> def add(x, y):
...     return x + y
...
>>> reduce(add, [1, 3, 5, 7, 9])
25</code></pre> 

如果要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场：

<pre><code>>>> def fn(x, y):
...     return x * 10 + y
...
>>> reduce(fn, [1, 3, 5, 7, 9])
13579</code></pre> 

这个例子本身没多大用处，但是，如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：

<pre><code>>>> def fn(x, y):
...     return x * 10 + y
...
>>> def char2num(s):
...     return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
...
>>> reduce(fn, map(char2num, '13579'))
13579</code></pre> 

<b>整理成一个str2int的函数就是：</b>

<pre><code>def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
    return reduce(fn, map(char2num, s))
</code></pre> 

还可以用lambda函数进一步简化成：

<pre><code>def char2num(s):
    return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]

def str2int(s):
    return reduce(lambda x,y: x*10+y, map(char2num, s))
</code></pre> 

<b>Python capitalize()将字符串的第一个字母变成大写,其他字母变小写。对于 8 位字节编码需要根据本地环境。</b>

<pre><code>>>> s = 'abdc'
>>> s.capitalize()
'Abdc'
</code></pre> 

<b>filter</b>
Python内建的filter()函数用于过滤序列。

和map()类似，filter()也接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

例如，在一个list中，删掉偶数，只保留奇数，可以这么写：

<pre><code>def is_odd(n):
    return n % 2 == 1

filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])
# 结果: [1, 5, 9, 15]
</code></pre> 

把一个序列中的空字符串删掉，可以这么写：

<pre><code>def not_empty(s):
    return s and s.strip()

filter(not_empty, ['A', '', 'B', None, 'C', '  '])
# 结果: ['A', 'B', 'C']
</code></pre> 

<b>Python strip() 方法用于移除字符串头尾指定的字符（默认为空格）。</b>

<pre><code>str = "0000000     Runoob  0000000"; 
print str.strip( '0' );  # 去除首尾字符 0
 
 
str2 = "   Runoob      ";   # 去除首尾空格
print str2.strip();
</code></pre> 

以上实例输出结果如下：

<pre><code>     Runoob  
Runoob
</code></pre> 

<pre><code>>>> str = "0000100     Runoob  0001000";
>>> print str.strip( '0' );  # 去除首尾字符 0
100     Runoob  0001
</code></pre> 

<b>sorted (通常规定，对于两个元素x和y，如果认为x < y，则返回-1，如果认为x == y，则返回0，如果认为x > y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。)</b>

sorted()函数也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。比如，如果要倒序排序，我们就可以自定义一个reversed_cmp函数：

<pre><code>def reversed_cmp(x, y):
    if x > y:
        return -1
    if x < y:
        return 1
    return 0
</code></pre> 

传入自定义的比较函数reversed_cmp，就可以实现倒序排序：

<pre><code>>>> sorted([36, 5, 12, 9, 21], reversed_cmp)
[36, 21, 12, 9, 5]
</code></pre> 

默认情况下，对字符串排序，是按照ASCII的大小比较的，由于'Z' < 'a'，结果，大写字母Z会排在小写字母a的前面。

现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：

<pre><code>def cmp_ignore_case(s1, s2):
    u1 = s1.upper()
    u2 = s2.upper()
    if u1 < u2:
        return -1
    if u1 > u2:
        return 1
    return 0
</code></pre> 

忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。

这样，我们给sorted传入上述比较函数，即可实现忽略大小写的排序：

<pre><code>>>> sorted(['bob', 'about', 'Zoo', 'Credit'], cmp_ignore_case)
['about', 'bob', 'Credit', 'Zoo']
</code></pre> 

<b>返回函数</b>
高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。

<pre><code>def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
</code></pre> 

当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：

<pre><code>>>> f = lazy_sum(1, 3, 5, 7, 9)
>>> f
&lt;function sum at 0x10452f668&gt;
</code></pre> 

调用函数f时，才真正计算求和的结果：

<pre><code>>>> f()
25
</code></pre> 

在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为<b>“闭包（Closure）”</b>的程序结构拥有极大的威力。

请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：

<pre><code>>>> f1 = lazy_sum(1, 3, 5, 7, 9)
>>> f2 = lazy_sum(1, 3, 5, 7, 9)
>>> f1==f2
False
</code></pre> 
f1()和f2()的调用结果互不影响。

<b>闭包</b>

注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。

另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：

<pre><code>def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
</code></pre> 

你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：

<pre><code>>>> f1()
9
>>> f2()
9
>>> f3()
9
</code></pre> 

全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。

返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。

如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：

<pre><code>>>> def count():
...     fs = []
...     for i in range(1, 4):
...         def f(j):
...             def g():
...                 return j*j
...             return g
...         fs.append(f(i))
...     return fs
... 
>>> f1, f2, f3 = count()
>>> f1()
1
>>> f2()
4
>>> f3()
9
</code></pre> 

缺点是代码较长，可利用lambda函数缩短代码。

#####匿名函数
<pre><code>>>> map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre> 

通过对比可以看出，匿名函数lambda x: x * x实际上就是：

<pre><code>def f(x):
    return x * x
</code></pre> 

关键字lambda表示匿名函数，冒号前面的x表示函数参数。

匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。

用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：

<pre><code>>>> f = lambda x: x * x
>>> f
<function <lambda> at 0x10453d7d0>
>>> f(5)
25
</code></pre> 

同样，也可以把匿名函数作为返回值返回，比如：

<pre><code>def build(x, y):
    return lambda: x * x + y * y
</code></pre> 

#####小结

Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。

#####装饰器
<pre><code>>>> def now():
...     print '2013-12-25'
...
>>> f = now
>>> f()
2013-12-25
</code></pre> 

现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。

<b>本质上，decorator就是一个返回函数的高阶函数</b>。所以，我们要定义一个能打印日志的decorator，可以定义如下：

<pre><code>def log(func):
    def wrapper(*args, **kw):
        print 'call %s():' % func.__name__
        return func(*args, **kw)
    return wrapper
</code></pre> 

观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：

<pre><code>@log
def now():
    print '2013-12-25'
</code></pre> 

调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：

<pre><code>>>> now()
call now():
2013-12-25
</code></pre> 

把@log放到now()函数的定义处，相当于执行了语句：

<pre><code>now = log(now)
</code></pre> 

由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。

wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。

如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：

<pre><code>@log('execute')
def now():
    print '2013-12-25'
</code></pre> 

执行结果如下：

<pre><code>>>> now()
execute now():
2013-12-25
</code></pre> 

和两层嵌套的decorator相比，3层嵌套的效果是这样的：

<pre><code>>>> now = log('execute')(now)
</code></pre> 

我们来剖析上面的语句，首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。

以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的'now'变成了'wrapper'：

<pre><code>>>> now.__name__
'wrapper'
</code></pre> 

因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。

不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：

<pre><code>import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print 'call %s():' % func.__name__
        return func(*args, **kw)
    return wrapper
</code></pre> 

或者针对带参数的decorator：

<pre><code>import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print '%s %s():' % (text, func.__name__)
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre> 

#####小结

在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。

decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。

#####偏函数
Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。

<pre><code>def int2(x, base=2):
    return int(x, base)</code></pre> 

<pre><code>>>> int2('1000000')
64
>>> int2('1010101')
85</code></pre> 

functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：

<pre><code>>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
64
>>> int2('1010101')
85</code></pre> 

所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。

注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：

<pre><code>>>> int2('1000000', base=10)
1000000</code></pre> 

最后，创建偏函数时，实际上可以接收<b>函数对象、\*args和**kw</b>这3个参数，当传入：

<pre><code>int2 = functools.partial(int, base=2)</code></pre> 

实际上固定了int()函数的关键字参数base，也就是：

<pre><code>int2('10010')</code></pre> 
相当于：

<pre><code>kw = { base: 2 }
int('10010', **kw)</code></pre> 

当传入：

<pre><code>max2 = functools.partial(max, 10)</code></pre> 
实际上会把10作为*args的一部分自动加到左边，也就是：

<pre><code>max2(5, 6, 7)</code></pre> 

相当于：

<pre><code>args = (10, 5, 6, 7)
max(*args)</code></pre> 
结果为10。

#####小结

当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。

#####模块
为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。

######使用模块
编写一个hello的模块：

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

' a test module '

__author__ = 'Michael Liao'

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print 'Hello, world!'
    elif len(args)==2:
        print 'Hello, %s!' % args[1]
    else:
        print 'Too many arguments!'

if __name__=='__main__':
    test()</code></pre> 

第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；

第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；

第6行使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；

以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。

后面开始就是真正的代码部分。

导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。

sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：

运行python hello.py获得的sys.argv就是['hello.py']；

运行python hello.py Michael获得的sys.argv就是['hello.py', 'Michael]。

最后，注意到这两行代码：

<pre><code>if __name__=='__main__':
    test()</code></pre> 

<b>当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</b>
<br>
我们可以用命令行运行hello.py看看效果：

<pre><code>$ python hello.py
Hello, world!
$ python hello.py Michael
Hello, Michael!</code></pre> 

#####别名

导入模块时，还可以使用别名，这样，可以在运行时根据当前环境选择最合适的模块。比如Python标准库一般会提供StringIO和cStringIO两个库，这两个库的接口和功能是一样的，但是cStringIO是C写的，速度更快，所以，你会经常看到这样的写法：

<pre><code>try:
    import cStringIO as StringIO
except ImportError: # 导入失败会捕获到ImportError
    import StringIO</code></pre> 

这样就可以优先导入cStringIO。如果有些平台不提供cStringIO，还可以降级使用StringIO。导入cStringIO时，用import ... as ...指定了别名StringIO，因此，后续代码引用StringIO即可正常工作。

由于Python是动态语言，函数签名一致接口就一样，因此，无论导入哪个模块后续代码都能正常工作。

#####作用域

在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。

正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；

类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名；

类似_xxx和__xxx这样的函数或变量就是非公开的（private），<b>不应该被直接引用</b>，比如_abc，__abc等；

<b>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</b>

private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：

<pre><code>def _private_1(name):
    return 'Hello, %s' % name

def _private_2(name):
    return 'Hi, %s' % name

def greeting(name):
    if len(name) > 3:
        return _private_1(name)
    else:
        return _private_2(name)</code></pre> 
我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：

外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。

#####使用__future__
Python提供了__future__模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。

在Python 2.x中，对于除法有两种情况，如果是整数相除，结果仍是整数，余数会被扔掉，这种除法叫“地板除”：

<pre><code>>>> 10 / 3
3</code></pre> 

要做精确除法，必须把其中一个数变成浮点数：
<pre><code>>>> 10.0 / 3
3.3333333333333335</code></pre> 

#####类和实例
面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。

可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性：

<pre><code>>>> bart.name = 'Bart Simpson'
>>> bart.name
'Bart Simpson'</code></pre> 

由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：

<pre><code>class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score</code></pre> 

注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。
<br>
<b>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：</b>

<pre><code>>>> bart = Student('Bart Simpson', 59)
>>> lisa = Student('Lisa Simpson', 87)
>>> bart.age = 8
>>> bart.age
8
>>> lisa.age
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in <module>
AttributeError: 'Student' object has no attribute 'age'</code></pre> 

#####访问限制
在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。

但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：

<pre><code>>>> bart = Student('Bart Simpson', 98)
>>> bart.score
98
>>> bart.score = 59
>>> bart.score
59</code></pre> 

如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：

<pre><code>class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print '%s: %s' % (self.__name, self.__score)</code></pre> 

改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了：

<pre><code>>>> bart = Student('Bart Simpson', 98)
>>> bart.__name
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in <module>
AttributeError: 'Student' object has no attribute '__name'</code></pre> 

这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。

需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。

有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。

双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。<b>不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name</b>，所以，仍然可以通过_Student__name来访问__name变量：

<pre><code>>>> bart._Student__name
'Bart Simpson'</code></pre> 

但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。

总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。


<pre><code>>>> import types
>>> type('abc')==types.StringType
True
>>> type(u'abc')==types.UnicodeType
True
>>> type([])==types.ListType
True
>>> type(str)==types.TypeType
True</code></pre> 
最后注意到有一种类型就叫TypeType，所有类型本身的类型就是TypeType，比如：
<pre><code>>>> type(int)==type(str)==types.TypeType
True</code></pre> 

可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是str或者unicode：

<pre><code>>>> isinstance('a', (str, unicode))
True
>>> isinstance(u'a', (str, unicode))
True</code></pre> 
由于str和unicode都是从basestring继承下来的，所以，还可以把上面的代码简化为：
<pre><code>>>> isinstance(u'a', basestring)
True</code></pre> 

我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法：

<pre><code>>>> class MyObject(object):
...     def __len__(self):
...         return 100
...
>>> obj = MyObject()
>>> len(obj)
100</code></pre> 

常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。

给实例绑定一个方法：

<pre><code>>>> def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
>>> from types import MethodType
>>> s.set_age = MethodType(set_age, s, Student) # 给实例绑定一个方法
>>> s.set_age(25) # 调用实例方法
>>> s.age # 测试结果
25</code></pre> 

但是，给一个实例绑定的方法，对另一个实例是不起作用的,此时可以给class绑定方法：

<pre><code>>>> def set_score(self, score):
...     self.score = score
...
>>> Student.set_score = MethodType(set_score, None, Student)</code></pre> 

使用__slots__
但是，如果我们想要限制class的属性怎么办？比如，只允许对Student实例添加name和age属性。

为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class能添加的属性：

<pre><code>>>> class Student(object):
...     __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
...</code></pre> 

<pre><code>>>> s = Student() # 创建新的实例
>>> s.name = 'Michael' # 绑定属性'name'
>>> s.age = 25 # 绑定属性'age'
>>> s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute 'score'</code></pre> 

使用__slots__要注意，__slots__定义的属性仅对当前类起作用，对继承的子类是不起作用的：

<pre><code>>>> class GraduateStudent(Student):
...     pass
...
>>> g = GraduateStudent()
>>> g.score = 9999</code></pre> 
除非在子类中也定义__slots__，这样，子类允许定义的属性就是自身的__slots__加上父类的__slots__。

装饰器（decorator）可以给函数动态加上功能。对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的

Mixin
Mixin的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个Mixin的功能，而不是设计多层次的复杂的继承关系。
</br>
</br>
现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：

<pre><code>http://api.server/user/friends
http://api.server/user/timeline/list</code></pre> 

如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。

利用完全动态的__getattr__，我们可以写出一个链式调用：

<pre><code>class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path</code></pre> 

试试：
<pre><code>>>> Chain().status.user.timeline.list
'/status/user/timeline/list'</code></pre> 

这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！

还有些REST API会把参数放到URL中，比如GitHub的API：

<pre><code>GET /users/:user/repos</code></pre> 

调用时，需要把:user替换为实际用户名。如果我们能写出这样的链式调用：

<pre><code>Chain().users('michael').repos</code></pre> 

就可以非常方便地调用API了。

#####动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。

#####我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。

序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。

#####反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。

Python提供两个模块来实现序列化：cPickle和pickle。这两个模块功能是一样的，区别在于cPickle是C语言写的，速度快，pickle是纯Python写的，速度慢，跟cStringIO和StringIO一个道理。用的时候，先尝试导入cPickle，如果失败，再导入pickle
<pre><code>try:
    import cPickle as pickle
except ImportError:
    import pickle</code></pre> 
   
    
#####file-like Object

像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。

StringIO就是在内存中创建的file-like Object，常用作临时缓冲。

Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。

有一点需要注意，就是反序列化得到的所有字符串对象默认都是unicode而不是str。由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str或unicode与JSON的字符串之间转换。

######Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。

######子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。

######正则表达式
编译
当我们在Python中使用正则表达式时，re模块内部会干两件事情：
编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
用编译后的正则表达式去匹配字符串。

如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：

<pre><code>>>> import re
# 编译:
>>> re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用：
>>> re_telephone.match('010-12345').groups()
('010', '12345')
>>> re_telephone.match('010-8086').groups()
('010', '8086')</code></pre> 
   编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。

